\documentclass[12pt,a4paper]{article}

% Encoding, Czech support
\usepackage[czech]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

% Math + code + images
\usepackage{amsmath}
\usepackage{graphicx}
\graphicspath{{images/}}
\usepackage{float}
\usepackage{listings}
\usepackage{caption}
\usepackage{hyperref}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{booktabs}

% Better Czech quotes
\usepackage{csquotes}

% Page setup
\usepackage{geometry}
\geometry{margin=2.5cm}

\begin{document}

% ============================================================
% Titulní strana ve stylu předchozí práce
% ============================================================
\begin{titlepage}
    \includegraphics[width=0.80\textwidth]{images/fav.pdf}
    \begin{center}
        \vspace{2cm}

        \LARGE
        Semestrální práce z KIV/PRO

        \Huge
        \textbf{Porovnání algoritmů Value Noise, Perlin Noise a Worley Noise}

        \vspace{1cm}

        \vfill

        \vspace{0.5cm}

        \normalsize
        \raggedright
        Autor: Vít Novotný \hfill Datum: \today

        \vspace{0.2cm}

    \end{center}
\end{titlepage}

\tableofcontents
\newpage

% ============================================================
\section{Zadání}
% ============================================================

Cílem práce je implementace algoritmů pro procedurální generování dvourozměrného šumu a jejich následné porovnání. 
Hlavní metodou je algoritmus \textbf{Perlin noise}, ke kterému jsou pro účely porovnání implementovány algoritmy 
\textbf{Value noise} a \textbf{Worley (cellular) noise}. 

Všechny algoritmy budou implementovány v jazyce Python a porovnávány při stejných parametrech 
(seed, měřítko, rozlišení). Výstupem budou grayscale obrázky, analýza vlastností jednotlivých noise metod a jejich vzájemné porovnání.

\newpage
% ============================================================
\section{Existující metody}
% ============================================================

\subsection{Value Noise}
Value noise je jednoduchý procedurální šum, ve kterém je každému rohu mřížky přiřazena pseudonáhodná skalární hodnota. Hodnota šumu uvnitř buňky se pak získává interpolací těchto čtyř hodnot, obvykle pomocí lineární nebo vyhlazené fade funkce. Výsledkem je hladký, vizuálně jednoduchý šum, který zachovává základní mřížkovou strukturu.

Výhodou value noise je jeho rychlá a snadná implementace a nízká výpočetní náročnost. Nevýhodou je omezená vizuální komplexnost a to, že výsledný šum může působit uměle nebo příliš pravidelně. Value noise se používá spíše jako úvodní metoda nebo základ pro složitější algoritmy, které z něj vycházejí. \cite{wikipedia_value_noise}

\subsection{Perlin Noise}
Perlin noise, který navrhl Ken Perlin v roce 1985, je gradientový šum. Místo náhodných hodnot přiřazuje každému rohu buňky náhodný gradientový vektor. Hodnota šumu se vypočítá jako skalární součin tohoto vektoru a směru k vyhodnocovanému bodu. Výsledný šum je následně plynule interpolován pomocí speciální vyhlazovací funkce.

Hlavní výhodou Perlinova šumu je jeho přirozený a spojitý vzhled, díky kterému se používá pro generování terénů, oblaků, ohně nebo organických textur. Nevýhodou je složitější implementace a možnost vzniku jemných mřížkových artefaktů. I přesto je Perlin noise dlouhodobě standardem v počítačové grafice a základní metodou mnoha dalších šumových algoritmů. \cite{wikipedia_perlin_noise}

\subsection{Worley Noise}
Worley noise, představený Stevenem Worleym v roce 1996, je šum založený na vzdálenosti. Každá buňka mřížky obsahuje náhodně umístěný feature point a hodnota šumu je určena vzdáleností k nejbližšímu z těchto bodů. Výsledné vzory připomínají Voroného diagramy nebo buněčné struktury.

Výhodou Worley noise je charakteristický, výrazně odlišný vzhled, vhodný pro textury jako kámen, pěna, popraskané povrchy nebo organické materiály. Nevýhodou je vyšší výpočetní náročnost a méně spojitý charakter výsledného šumu. Oproti Perlinovu šumu vytváří ostřejší a výraznější obrazce. \cite{wikipedia_worley_noise}

\newpage
% ============================================================
\section{Zvolené řešení}
% ============================================================

\subsection{Sjednocené rozhraní}

Pro všechny tři algoritmy byla zvolena metoda:
\begin{verbatim}
sample(x : float, y : float) -> float in [0,1]
\end{verbatim}

\subsection{Pseudokód algoritmů}

\subsubsection*{Value Noise – pseudokód}

\begin{algorithm}[H]
\caption{ValueNoise.sample(x, y)}
\begin{algorithmic}[1]
\State Spočítej celočíselnou souřadnici buňky:
\State \quad $x_0 \gets \lfloor x \rfloor$, $y_0 \gets \lfloor y \rfloor$
\State \quad $x_1 \gets x_0 + 1$, $y_1 \gets y_0 + 1$
\State
\State Spočítej lokální souřadnice bodu v buňce:
\State \quad $u \gets x - x_0$, $v \gets y - y_0$ \Comment{$u,v \in [0,1)$}
\State
\State Získej náhodné hodnoty v rozích buňky:
\State \quad $v_{00} \gets \text{randomValue}(x_0, y_0)$
\State \quad $v_{10} \gets \text{randomValue}(x_1, y_0)$
\State \quad $v_{01} \gets \text{randomValue}(x_0, y_1)$
\State \quad $v_{11} \gets \text{randomValue}(x_1, y_1)$
\State
\State Spočítej vyhlazené váhy v osách:
\State \quad $s_x \gets fade(u)$
\State \quad $s_y \gets fade(v)$
\State
\State Interpoluj v ose $x$:
\State \quad $a \gets lerp(v_{00}, v_{10}, s_x)$
\State \quad $b \gets lerp(v_{01}, v_{11}, s_x)$
\State
\State Výsledná hodnota je interpolace v ose $y$:
\State \quad \Return $lerp(a, b, s_y)$
\end{algorithmic}
\end{algorithm}

\subsubsection*{Perlin Noise – pseudokód}

\begin{algorithm}[H]
\caption{PerlinNoise.sample(x, y)}
\begin{algorithmic}[1]
\State Spočítej celočíselnou souřadnici buňky:
\State \quad $x_0 \gets \lfloor x \rfloor$, $y_0 \gets \lfloor y \rfloor$
\State \quad $x_1 \gets x_0 + 1$, $y_1 \gets y_0 + 1$
\State
\State Spočítej lokální souřadnice bodu v buňce:
\State \quad $u \gets x - x_0$, $v \gets y - y_0$
\State
\State Získej gradientové vektory v rozích buňky:
\State \quad $g_{00} \gets \text{randomGradient}(x_0, y_0)$
\State \quad $g_{10} \gets \text{randomGradient}(x_1, y_0)$
\State \quad $g_{01} \gets \text{randomGradient}(x_0, y_1)$
\State \quad $g_{11} \gets \text{randomGradient}(x_1, y_1)$
\State
\State Spočítej vektory od rohu k bodu:
\State \quad $d_{00} \gets (u, v)$
\State \quad $d_{10} \gets (u - 1, v)$
\State \quad $d_{01} \gets (u, v - 1)$
\State \quad $d_{11} \gets (u - 1, v - 1)$
\State
\State Spočítej skalární součiny (příspěvky z rohů):
\State \quad $n_{00} \gets dot(g_{00}, d_{00})$
\State \quad $n_{10} \gets dot(g_{10}, d_{10})$
\State \quad $n_{01} \gets dot(g_{01}, d_{01})$
\State \quad $n_{11} \gets dot(g_{11}, d_{11})$
\State
\State Spočítej vyhlazené váhy v osách:
\State \quad $s_x \gets fade(u)$
\State \quad $s_y \gets fade(v)$
\State
\State Interpoluj příspěvky v ose $x$:
\State \quad $a \gets lerp(n_{00}, n_{10}, s_x)$
\State \quad $b \gets lerp(n_{01}, n_{11}, s_x)$
\State
\State Výsledná hodnota je interpolace v ose $y$:
\State \quad $h \gets lerp(a, b, s_y)$
\State
\State Normalizuj do intervalu $[0,1]$:
\State \quad \Return $0.5 \cdot h + 0.5$
\end{algorithmic}
\end{algorithm}

\subsubsection*{Worley Noise – pseudokód}

\begin{algorithm}[H]
\caption{WorleyNoise.sample(x, y)}
\begin{algorithmic}[1]
\State Najdi index buňky, která obsahuje bod $(x, y)$:
\State \quad $i_0 \gets \lfloor x \rfloor$, $j_0 \gets \lfloor y \rfloor$
\State
\State Inicializuj minimální vzdálenost:
\State \quad $minDist \gets +\infty$
\State
\State Pro všechny sousední buňky v okolí $3 \times 3$:
\For{$\Delta j \gets -1$ \textbf{to} $1$}
  \For{$\Delta i \gets -1$ \textbf{to} $1$}
    \State $i \gets i_0 + \Delta i$
    \State $j \gets j_0 + \Delta j$
    \State Získej pozici náhodného feature--pointu v buňce $(i, j)$:
    \State \quad $(p_x, p_y) \gets \text{randomPointInCell}(i, j)$
    \State Spočítej eukleidovskou vzdálenost od $(x, y)$:
    \State \quad $d \gets \sqrt{(p_x - x)^2 + (p_y - y)^2}$
    \State Aktualizuj minimální vzdálenost:
    \State \quad $minDist \gets \min(minDist, d)$
  \EndFor
\EndFor
\State
\State Normalizuj vzdálenost do intervalu $[0,1]$:
\State \quad \Return $\text{normalize}(minDist)$
\end{algorithmic}
\end{algorithm}

\newpage
% ============================================================
\section{Experimenty a výsledky}
% ============================================================

Experimenty byly provedeny v jazyce Python. 
Všechny tři noise algoritmy byly testovány se stejnými parametry:

\begin{itemize}
    \item seed = 1234
    \item rozlišení 512$\times$512 pixelů
    \item scale = 0{,}02
\end{itemize}

\subsection{Výsledné obrázky}

\begin{figure}[H]
\centering
\includegraphics[width=0.45\linewidth]{value_noise.png}
\caption{Value Noise}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.45\linewidth]{perlin_noise.png}
\caption{Perlin Noise}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.45\linewidth]{worley_noise.png}
\caption{Worley Noise}
\end{figure}

\subsection{Porovnání}

\subsubsection{Value Noise}

Value noise je vizuálně nejjednodušší ze všech tří testovaných metod. Jeho hlavní vlastností je celková hladkost, která vychází z interpolace náhodných hodnot v rozích buněk. Přechody mezi světlými a tmavými oblastmi jsou poměrně plynulé, nicméně při větším přiblížení je možné pozorovat pravidelnou mřížkovou strukturu. Ta je způsobena tím, že samotné náhodné hodnoty nejsou nijak spojité – pouze interpolované.

Výsledný šum je poměrně „měkký“ a jednoduchý, což může být výhodou nebo nevýhodou v závislosti na aplikaci. Hodí se pro základní generování textur nebo jemné výškové mapy, kde nejsou vyžadovány jemné detaily ani příliš přirozený vzhled. Pro komplexnější struktury je ale Value noise většinou nedostačující. 

\subsubsection{Perlin Noise}

Perlinův šum je z testovaných metod nejvyváženější. Vytváří vizuálně spojitější a hladší struktury než Value noise a zároveň nabízí mnohem přirozenější variabilitu. Díky gradientové konstrukci je šum plynulý ve všech směrech a přechody mezi oblastmi jsou jemné. Perlin noise také nevykazuje výrazné blokové artefakty, které jsou typické pro Value noise.

Jedním z mála možných artefaktů je jemná mřížková stopa při extrémním přiblížení, ale u standardního použití je prakticky neviditelná. Perlinův šum se velmi dobře hodí pro generování terénů, oblaků, organických vzorů nebo přírodních textur. Je to univerzální metoda, která poskytuje realistický, hladký charakter a lze ji snadno kombinovat do více oktáv (fBm), čímž vznikají bohaté a detailní struktury. 


\subsection{Worley Noise}

Worley noise se od předchozích metod zásadně liší. Nevytváří hladké nebo spojité struktury, ale výrazné buněčné vzory připomínající Voroného diagram. Ty jsou charakteristické tmavými oblastmi v místech nejbližších feature pointů a světlejšími přechody směrem k hranicím buněk. Šum nepůsobí hladce, ale spíše ostře a segmentovaně.

Tento typ šumu je velmi vhodný pro efekty, které mají přirozeně buněčný charakter — například textury kamene, popraskaných povrchů, lávy, pěny nebo biomorfních struktur. Naopak se nehodí pro generování terénu nebo měkkých přírodních tvarů, kde je žádoucí spojitost a hladkost. 

\subsection{Tabulka výsledků}

\begin{table}[H]
\centering
\small
\begin{tabular}{lcccc}
\toprule
Metoda & Hladkost & Artefakty & Charakter & Typické použití \\
\midrule
Value Noise & střední & mřížkové bloky & jednoduchý & základní textury \\
Perlin Noise & vysoká & minimální & organický & terény, mraky \\
Worley Noise & nízká & buněčné tvary & segmentovaný & kámen, praskliny \\
\bottomrule
\end{tabular}
\caption{Porovnání vlastností jednotlivých noise algoritmů.}
\end{table}

\newpage
% ============================================================
\section{Závěr}
% ============================================================

V této práci byly implementovány a porovnány tři algoritmy pro procedurální generování dvourozměrného šumu: Value Noise, Perlin Noise a Worley Noise. Každý z nich představuje odlišný přístup k tvorbě pseudonáhodných struktur a vykazuje specifické vizuální i technické vlastnosti. Implementace byla sjednocena pod jednotné rozhraní a jednotlivé metody byly testovány za stejných podmínek, což umožnilo jejich objektivní porovnání.

Z experimentů vyplynulo, že Value Noise poskytuje nejjednodušší a nejhladší výsledek, avšak jeho vizuální komplexita je omezená a často trpí mřížkovými artefakty. Perlin Noise se ukázal jako nejvyváženější metoda — vytváří spojité, organické struktury s minimem artefaktů a je vhodný pro širokou škálu aplikací, zejména v oblasti počítačové grafiky. Naproti tomu Worley Noise produkuje výrazně odlišné, buněčné a segmentované vzory, které se nehodí pro generování plynulých povrchů, ale jsou ideální pro textury jako kámen, pěna nebo přírodní útvary s ostřejší strukturou.

Celkově lze říci, že každá z metod má své specifické využití. Perlin Noise je univerzální volbou pro přirozeně působící šum, Value Noise se hodí pro jednodušší textury a Worley Noise dominuje při generování buněčných nebo voronoi-jako struktur. Možným rozšířením této práce je implementace více oktáv (fractal Brownian motion), kombinace různých typů šumu které by umožnily vytvářet ještě komplexnější a realističtější procedurální vzory.

\newpage
\bibliographystyle{plain}
\bibliography{citations}



\end{document}
